#!/usr/bin/env bash
set -e

TODAY=$(date +%Y-%m-%d)
REPORT_FILE=".agent/audit/${TODAY}_scan.md"

# Helper for printing headers
function h2() {
    echo "" >> "$REPORT_FILE"
    echo "## $1" >> "$REPORT_FILE"
    echo "Scanning $1..."
}

echo "# Security Audit Report - ${TODAY}" > "$REPORT_FILE"
echo "**Generated by:** Antigravity Secure Scan Protocol" >> "$REPORT_FILE"
echo "" >> "$REPORT_FILE"

# ==============================================================================
# 1. KNOWN VULNERABILITIES (CVEs)
# ==============================================================================
h2 "1. Vulnerability Scan (vulnix)"
echo "Checking system closure for known CVEs..."
echo "\`\`\`" >> "$REPORT_FILE"

# Run vulnix on the entire system closure
# We use --json for machine parsing if needed, but text is verifyable by human
if vulnix --whitelists .agent/audit/whitelist.toml . >> "$REPORT_FILE" 2>&1; then
  echo "‚úÖ No known vulnerabilities found."
else
  # Vulnix returns non-zero if vulnerabilities are found
  echo "‚ö†Ô∏è  Vulnerabilities detected! Check report."
fi
echo "\`\`\`" >> "$REPORT_FILE"

# ==============================================================================
# 2. STATIC ANALYSIS (Linting)
# ==============================================================================
h2 "2. Static Code Analysis (statix)"
echo "Linting Nix code for security anti-patterns..."
echo "\`\`\`" >> "$REPORT_FILE"
if statix check . >> "$REPORT_FILE" 2>&1; then
    echo "‚úÖ Code looks clean."
    echo "No issues found." >> "$REPORT_FILE"
else
    echo "‚ö†Ô∏è  Static analysis found issues."
fi
echo "\`\`\`" >> "$REPORT_FILE"

# ==============================================================================
# 3. DEAD CODE DETECTION
# ==============================================================================
h2 "3. Dead Code Detection (deadnix)"
echo "Scanning for unused code..."
echo "\`\`\`" >> "$REPORT_FILE"
if deadnix . >> "$REPORT_FILE" 2>&1; then
    echo "‚úÖ No dead code found."
    echo "No dead code found." >> "$REPORT_FILE"
else
    echo "‚ö†Ô∏è  Dead code detected."
fi
echo "\`\`\`" >> "$REPORT_FILE"

# ==============================================================================
# 4. CONFIGURATION COMPLIANCE
# ==============================================================================
h2 "4. Configuration Compliance Checks"
echo "Verifying critical security settings..."

# Function to check a Nix option value
check_option() {
    local host=$1
    local option=$2
    local expected=$3
    
    echo -n "- Checking $option on $host... " >> "$REPORT_FILE"
    
    # Eval the option using JSON to handle booleans and lists correctly
    ACTUAL=$(nix eval --json ".#nixosConfigurations.$host.config.$option" 2>/dev/null | jq -c -r . || echo "ERROR")
    
    if [[ "$ACTUAL" == "$expected" ]]; then
        echo "‚úÖ PASS" >> "$REPORT_FILE"
    else
        echo "‚ùå FAIL (Expected: $expected, Got: $ACTUAL)" >> "$REPORT_FILE"
        echo "‚ö†Ô∏è  Compliance Fail: $option"
    fi
}

echo "### Workstation Compliance" >> "$REPORT_FILE"
echo "### Workstation Compliance" >> "$REPORT_FILE"
check_option "nixos-nvme" "services.openssh.settings.PermitRootLogin" "no"
check_option "nixos-nvme" "services.openssh.settings.PasswordAuthentication" "false"
# Check for EITHER networking.firewall OR firewalld
FIREWALLD=$(nix eval --json ".#nixosConfigurations.nixos-nvme.config.services.firewalld.enable" 2>/dev/null | jq -r . || echo "false")
NET_FIREWALL=$(nix eval --json ".#nixosConfigurations.nixos-nvme.config.networking.firewall.enable" 2>/dev/null | jq -r . || echo "false")

echo -n "- Checking Firewall status... " >> "$REPORT_FILE"
if [[ "$FIREWALLD" == "true" || "$NET_FIREWALL" == "true" ]]; then
    echo "‚úÖ PASS (Firewall enabled)" >> "$REPORT_FILE"
else
     echo "‚ùå FAIL (Neither firewalld nor networking.firewall enabled)" >> "$REPORT_FILE"
     echo "‚ö†Ô∏è  Compliance Fail: Firewall"
fi
check_option "nixos-nvme" "nix.settings.trusted-users" '["root","@wheel"]'

# ==============================================================================
# 5. SECRET SCAN
# ==============================================================================
h2 "5. Data Leak Scan"
echo "Scanning for personal data (Emails, Keys, Tokens)..."

# Regex for common leaks
# 1. Private Keys (BEGIN RSA...)
# 2. AWS/API Tokens
# 3. Emails (aggressive)
LEAK_REGEX="(BEGIN .* PRIVATE KEY|AWS_ACCESS_KEY_ID|AKIA[0-9A-Z]{16}|[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,})"

# We use grep with line numbers, then filter out known safe patterns
if grep -rE "$LEAK_REGEX" . \
    --exclude-dir=.git \
    --exclude-dir=.agent \
    --exclude-dir=.terraform \
    --exclude-dir=result \
    --exclude="flake.lock" \
    | grep -vFf <(jq -r '.[]' .agent/audit/grep_ignore.json) >> "$REPORT_FILE"; then
    
    echo "‚ùå POTENTIAL LEAK FOUND" >> "$REPORT_FILE"
    echo "üö® ALERT: Potential sensitive data found! Check report."
else
    echo "‚úÖ No sensitive patterns found." >> "$REPORT_FILE"
    echo "‚úÖ No leaks detected."
fi

echo ""
echo "üìÑ Detailed Report generated at: ${REPORT_FILE}"
cat "$REPORT_FILE" | gum format # Use glow/gum to display if available
